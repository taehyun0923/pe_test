from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import parse_qs
import datetime
import ssl
import os
import sys

# =========================================================================
# Kali HTTPS 로그 리스너 (포트 443) - 오류 수정 버전
# =========================================================================

HOST = "0.0.0.0" # 모든 인터페이스에서 수신
PORT = 443       # HTTPS 포트

# 로그 저장 디렉토리 설정
LOG_DIR = "received_logs"
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)
    print(f"[INFO] 로그 저장 디렉토리 생성됨: {LOG_DIR}")

class HTTPPostHandler(BaseHTTPRequestHandler):
    """
    들어오는 HTTPS POST 요청을 처리하고 데이터를 저장하는 핸들러
    """
    
    def _set_headers(self, status_code=200):
        """클라이언트에게 응답 헤더를 설정합니다."""
        self.send_response(status_code)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()
    
    def do_POST(self):
        """POST 요청을 처리합니다 (로그 데이터 수신)."""
        content_length = int(self.headers.get('Content-Length', 0))
        
        if content_length == 0:
            self._set_headers(400)
            self.wfile.write(b"Error: Content-Length is 0.")
            return

        post_data = self.rfile.read(content_length)
        
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        
        try:
            # URL 인코딩된 데이터 파싱
            parsed_data = parse_qs(post_data.decode('utf-8', errors='ignore'), keep_blank_values=True)
            
            # 파싱된 데이터 추출
            filename = parsed_data.get('filename', ['received_log.txt'])[0]
            log_content_raw = parsed_data.get('content', [''])[0]
            
            # 클라이언트 스크립트에서 전송되는 추가 메타데이터 처리
            dummy_data_size = len(parsed_data.get('dummy_data', [''])[0])
            request_id = parsed_data.get('request_id', ['N/A'])[0]
            thread_id = parsed_data.get('thread_id', ['N/A'])[0]
            
            # --- 파일명 안전성 확보를 위한 수정된 로직 ---
            # 파일 경로로 해석될 수 있는 문자(/, :)를 언더바(_)로 대체합니다.
            clean_thread_id = thread_id.replace('/', '_').replace(':', '_')
            clean_request_id = request_id.replace('/', '_').replace(':', '_')
            clean_filename = filename.replace('/', '_').replace(':', '_')
            
            # 최종 파일명 설정
            save_filename = os.path.join(LOG_DIR, f"received_{timestamp}_TID{clean_thread_id}_RID{clean_request_id}_{clean_filename}")
            
            # 디스크에 로그 저장
            with open(save_filename, 'w', encoding='utf-8') as f:
                f.write(f"--- POST Header Info ---\n")
                f.write(f"Timestamp: {timestamp}\n")
                f.write(f"Source IP: {self.client_address[0]}\n")
                f.write(f"Total Body Size: {content_length} bytes\n")
                f.write(f"Dummy Payload Size: {dummy_data_size} bytes\n")
                f.write(f"Log Content Size: {len(log_content_raw)} bytes\n")
                f.write(f"--- System Log Content ---\n")
                f.write(log_content_raw)
            
            # 수신 성공 메시지 출력
            print(f"[{timestamp}] SUCCESS: Log received | TID:{clean_thread_id} | ReqID:{clean_request_id} | IP:{self.client_address[0]} | Size:{content_length/1024:.2f} KB")
            
            self._set_headers(200)
            self.wfile.write(b"Log received successfully.")
            
        except Exception as e:
            # 오류 발생 시, 오류 메시지에 파일 경로가 포함되지 않도록 주의
            print(f"[{timestamp}] ERROR: Failed to process POST request. Error: [Errno 2] Check filename variables. Actual Error: {e}")
            self._set_headers(500)
            self.wfile.write(f"Server error: {e}".encode())
    
    def log_message(self, format, *args):
        """HTTP 서버의 기본 로그 메시지를 커스터마이즈합니다."""
        # 200, 500 응답에 대한 상세 로그는 do_POST에서 출력하므로 기본 로그는 억제
        if args[1] not in ('200', '500'):
             timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
             print(f"[{timestamp}] {self.client_address[0]} - {format % args}")

def run_server():
    """HTTPS 서버를 시작합니다."""
    server_address = (HOST, PORT)
    
    try:
        # 1. SSL Context 생성 (TLS 1.2 이상 사용 권장)
        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER) 
        
        # 2. 인증서 파일 로드
        cert_file = os.path.join(os.getcwd(), "server.pem")
        key_file = os.path.join(os.getcwd(), "server.key")
        
        if not os.path.exists(cert_file) or not os.path.exists(key_file):
            print("\n[CRITICAL ERROR] SSL/TLS 인증서 파일(server.pem 또는 server.key)을 찾을 수 없습니다.")
            print(f"현재 디렉토리: {os.getcwd()}")
            print("인증서 생성 명령어를 실행하여 파일을 생성했는지 확인하십시오.")
            return

        context.load_cert_chain(certfile=cert_file, keyfile=key_file)
        
        # 3. HTTPS 서버 인스턴스 생성
        httpd = HTTPServer(server_address, HTTPPostHandler)
        
        # 4. 서버 소켓을 SSL Context로 래핑하여 HTTPS 적용
        httpd.socket = context.wrap_socket(httpd.socket, server_side=True)

        print("="*70)
        print(f"*** Kali HTTPS Listener started on https://{HOST}:{PORT} ***")
        print(f"*** Listening for POST requests ***")
        print(f"*** Press Ctrl+C to stop the server ***")
        print("="*70)
        
        httpd.serve_forever()
        
    except PermissionError:
        print(f"\n[CRITICAL ERROR] 권한 거부(Permission denied).")
        print(f"포트 {PORT}는 루트 권한을 필요로 합니다. 'sudo python3 {sys.argv[0]}'로 실행해 주십시오.")
        
    except OSError as e:
        if e.errno == 98: # Address already in use
            print(f"\n[CRITICAL ERROR] 포트 {PORT}가 이미 사용 중입니다.")
            print(f"다른 서비스가 포트 {PORT}를 사용하고 있는지 확인하십시오.")
        else:
            print(f"\n[OS ERROR] 예상치 못한 OS 오류가 발생했습니다: {e}")
            
    except KeyboardInterrupt:
        print("\n\n[INFO] 사용자 요청으로 서버 중지됨 (Ctrl+C)")
        
    except Exception as e:
        print(f"\n[SERVER ERROR] 서버 실행 중 예상치 못한 오류가 발생했습니다: {e}")

if __name__ == "__main__":
    run_server()