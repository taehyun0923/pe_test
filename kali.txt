iimport http.server
from http.server import BaseHTTPRequestHandler
from urllib.parse import parse_qs
import datetime
import ssl # ★★★ 올바른 모듈 이름은 'ssl'입니다. 'sssl'이 아닌지 확인하세요. ★★★
import os

# =========================================================================
# Kali HTTPS 로그 리스너 (포트 443) - SSL Context 적용 버전
# - SSL/TLS 암호화된 HTTPS 데이터를 수신합니다.
# - Kali Linux에서 'sudo'로 실행해야 합니다. (443 포트는 특권 포트)
#
# ★★★ 서버 실행 전, 인증서 파일 생성 필수 ★★★
# 터미널에서 다음 명령어를 실행하여 'server.key'와 'server.pem' 파일을 생성하세요.
# $ openssl req -new -x509 -keyout server.key -out server.pem -days 365 -nodes
# =========================================================================

HOST = "0.0.0.0" # 모든 인터페이스에서 수신
PORT = 443       # HTTPS 포트

# 리스너가 저장할 로그 파일 디렉토리
LOG_DIR = "received_logs"
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)
    print(f"[INFO] 로그 저장 디렉토리 생성됨: {LOG_DIR}")

class HTTPPostHandler(BaseHTTPRequestHandler):
    """
    들어오는 HTTPS POST 요청을 처리하고 데이터를 저장하는 핸들러
    """
    
    def _set_headers(self, status_code=200):
        """클라이언트에게 응답 헤더를 설정합니다."""
        self.send_response(status_code)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()
    
    def do_POST(self):
        """POST 요청을 처리합니다 (로그 데이터 수신)."""
        content_length = int(self.headers.get('Content-Length', 0))
        
        if content_length == 0:
            self._set_headers(400)
            self.wfile.write(b"Error: Content-Length is 0.")
            return

        post_data = self.rfile.read(content_length)
        
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        
        try:
            # URL 인코딩된 데이터 파싱
            parsed_data = parse_qs(post_data.decode('utf-8', errors='ignore'), keep_blank_values=True)
            
            # 파싱된 데이터에서 파일명과 내용을 추출 (리스트 형태로 반환되므로 첫 번째 요소 사용)
            # 클라이언트 스크립트에서 더미 데이터와 요청 ID도 함께 전송되므로 이들도 처리합니다.
            filename = parsed_data.get('filename', ['received_log.txt'])[0]
            log_content_raw = parsed_data.get('content', [''])[0]
            dummy_data_size = len(parsed_data.get('dummy_data', [''])[0])
            request_id = parsed_data.get('request_id', ['N/A'])[0]
            thread_id = parsed_data.get('thread_id', ['N/A'])[0]
            
            # 파일명에 타임스탬프 추가
            save_filename = os.path.join(LOG_DIR, f"received_{timestamp}_TID{thread_id}_RID{request_id}_{filename.replace('/', '_').replace(':', '_')}")
            
            # 디스크에 로그 저장
            with open(save_filename, 'w', encoding='utf-8') as f:
                f.write(f"--- POST Header Info ---\n")
                f.write(f"Timestamp: {timestamp}\n")
                f.write(f"Source IP: {self.client_address[0]}\n")
                f.write(f"Request URI: {self.path}\n")
                f.write(f"Total Body Size: {content_length} bytes\n")
                f.write(f"Dummy Payload Size: {dummy_data_size} bytes\n")
                f.write(f"Log Content Size: {len(log_content_raw)} bytes\n")
                f.write(f"--- System Log Content ---\n")
                f.write(log_content_raw)
            
            # 수신 성공 메시지 출력
            print(f"[{timestamp}] SUCCESS: Log received | TID:{thread_id} | ReqID:{request_id} | IP:{self.client_address[0]} | Size:{content_length/1024:.2f} KB")
            
            self._set_headers(200)
            self.wfile.write(b"Log received successfully.")
            
        except Exception as e:
            print(f"[{timestamp}] ERROR: Failed to process POST request. Error: {e}")
            self._set_headers(500)
            self.wfile.write(f"Server error: {e}".encode())
    
    def log_message(self, format, *args):
        """HTTP 서버의 기본 로그 메시지를 커스터마이즈합니다."""
        # 기본 로그를 억제하고 필요한 정보만 출력 (POST 요청은 do_POST에서 상세 출력)
        if args[1] not in ('200', '500'):
             timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
             print(f"[{timestamp}] {self.client_address[0]} - {format % args}")

def run_server():
    """HTTPS 서버를 시작합니다."""
    server_address = (HOST, PORT)
    
    try:
        httpd = http.server.HTTPServer(server_address, HTTPPostHandler)
        
        # ★★★ SSL/TLS 소켓 래핑 (HTTPS 적용) - SSL Context 사용 ★★★
        # 1. SSL Context 생성 (TLS 1.2 이상 사용 권장)
        # Note: PROTOCOL_TLS_SERVER는 Python 3.6+에서 사용 가능합니다.
        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER) 
        
        # 2. 인증서 파일 로드
        try:
            context.load_cert_chain(certfile="./server.pem", keyfile="./server.key")
        except FileNotFoundError:
            print("\n[CRITICAL ERROR] SSL/TLS 인증서 파일(server.pem 또는 server.key)을 찾을 수 없습니다.")
            print("위의 '★★★ 서버 실행 전, 인증서 파일 생성 필수 ★★★' 섹션의 명령어를 실행하여 파일을 생성했는지 확인하십시오.")
            return
        
        # 3. 서버 소켓을 SSL Context로 래핑
        httpd.socket = context.wrap_socket(httpd.socket, server_side=True)
        # 이전의 ssl.wrap_socket(httpd.socket, ...) 호출과 동일한 기능이지만 더 명확합니다.

        print("="*70)
        print(f"*** Kali HTTPS Listener started on https://{HOST}:{PORT} ***")
        print(f"*** Listening for POST requests to /upload endpoint ***")
        print(f"*** Press Ctrl+C to stop the server ***")
        print("="*70)
        
        httpd.serve_forever()
        
    except PermissionError:
        print(f"\n[CRITICAL ERROR] 권한 거부(Permission denied).")
        print(f"포트 {PORT}는 루트 권한을 필요로 합니다. 'sudo'로 실행해 주십시오.")
        
    except OSError as e:
        if e.errno == 98: # Address already in use
            print(f"\n[CRITICAL ERROR] 포트 {PORT}가 이미 사용 중입니다.")
            print(f"다른 서비스가 포트 {PORT}를 사용하고 있는지 확인하십시오.")
            print(f"확인 명령어: sudo netstat -tulpn | grep :{PORT}")
        else:
            print(f"\n[OS ERROR] 예상치 못한 OS 오류가 발생했습니다: {e}")
            
    except Exception as e:
        print(f"\n[SERVER ERROR] 서버 실행 중 예상치 못한 오류가 발생했습니다: {e}")

if __name__ == "__main__":
    run_server()