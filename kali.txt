import http.server
from http.server import BaseHTTPRequestHandler
from urllib.parse import parse_qs
import datetime
import ssl
import os

# =========================================================================
# Kali HTTPS 로그 리스너 (포트 443)
# - SSL/TLS 암호화된 HTTPS 데이터를 수신합니다.
# - Kali Linux에서 'sudo'로 실행해야 합니다. (443 포트는 특권 포트)
#
# ★★★ 서버 실행 전, 인증서 파일 생성 필수 ★★★
# 터미널에서 다음 명령어를 실행하여 'server.pem'과 'server.key' 파일을 생성하세요.
# $ openssl req -new -x509 -keyout server.key -out server.pem -days 365 -nodes
# =========================================================================

HOST = "0.0.0.0" # 모든 인터페이스에서 수신
PORT = 443       # HTTPS 포트

# 리스너가 저장할 로그 파일 디렉토리
LOG_DIR = "received_logs"
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)
    print(f"[INFO] 로그 저장 디렉토리 생성됨: {LOG_DIR}")

class HTTPPostHandler(BaseHTTPRequestHandler):
    """
    들어오는 HTTPS POST 요청을 처리하고 데이터를 저장하는 핸들러
    """
    
    def _set_headers(self, status_code=200):
        """클라이언트에게 응답 헤더를 설정합니다."""
        self.send_response(status_code)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()
    
    def do_POST(self):
        """POST 요청을 처리합니다 (로그 데이터 수신)."""
        content_length = int(self.headers.get('Content-Length', 0))
        # 요청 본문의 길이
        
        if content_length == 0:
            self._set_headers(400)
            self.wfile.write(b"Error: Content-Length is 0.")
            return

        post_data = self.rfile.read(content_length)
        # 요청 본문 읽기
        
        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        
        try:
            # URL 인코딩된 데이터 파싱
            parsed_data = parse_qs(post_data.decode('utf-8', errors='ignore'), keep_blank_values=True)
            
            # 파싱된 데이터에서 파일명과 내용을 추출 (리스트 형태로 반환되므로 첫 번째 요소 사용)
            filename = parsed_data.get('filename', ['received_log.txt'])[0]
            log_content_raw = parsed_data.get('content', [''])[0]
            
            # 파일명에 타임스탬프 추가
            save_filename = os.path.join(LOG_DIR, f"received_{timestamp}_{filename.replace('/', '_').replace(':', '_')}")
            
            # 디스크에 로그 저장
            with open(save_filename, 'w', encoding='utf-8') as f:
                f.write(log_content_raw)
            
            # 수신 성공 메시지 출력
            print(f"[{timestamp}] SUCCESS: Log received and saved to {save_filename}")
            print(f"[{timestamp}] Source IP: {self.client_address[0]}")
            print(f"[{timestamp}] Data size: {len(log_content_raw) / 1024:.2f} KB (Payload Only)")
            
            self._set_headers(200)
            self.wfile.write(b"Log received successfully.")
            
        except Exception as e:
            print(f"[{timestamp}] ERROR: Failed to process POST request. Error: {e}")
            self._set_headers(500)
            self.wfile.write(f"Server error: {e}".encode())
    
    def log_message(self, format, *args):
        """HTTP 서버의 기본 로그 메시지를 커스터마이즈합니다."""
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        # POST 요청에 대한 자세한 로그는 do_POST 내부에서 처리되므로, 기타 로그만 간단히 출력
        if args[1] not in ('200', '500'): # 200, 500 응답은 do_POST에서 출력하므로 생략
             print(f"[{timestamp}] {self.client_address[0]} - {format % args}")

def run_server():
    """HTTPS 서버를 시작합니다."""
    server_address = (HOST, PORT)
    
    try:
        httpd = http.server.HTTPServer(server_address, HTTPPostHandler)
        
        # ★★★ SSL/TLS 소켓 래핑 (HTTPS 적용) ★★★
        # server.pem과 server.key 파일이 현재 디렉토리에 있어야 합니다.
        try:
            httpd.socket = ssl.wrap_socket(httpd.socket,
                                           keyfile="./server.key", 
                                           certfile="./server.pem", 
                                           server_side=True)
        except FileNotFoundError:
            print("\n[CRITICAL ERROR] SSL/TLS 인증서 파일(server.pem 또는 server.key)을 찾을 수 없습니다.")
            print("위의 '★★★ 서버 실행 전, 인증서 파일 생성 필수 ★★★' 섹션의 명령어를 실행하여 파일을 생성했는지 확인하십시오.")
            return

        print("="*70)
        print(f"*** Kali HTTPS Listener started on https://{HOST}:{PORT} ***")
        print(f"*** Listening for POST requests to /upload endpoint ***")
        print(f"*** Press Ctrl+C to stop the server ***")
        print("="*70)
        
        httpd.serve_forever()
        
    except PermissionError:
        print(f"\n[CRITICAL ERROR] 권한 거부(Permission denied).")
        print(f"포트 {PORT}는 루트 권한을 필요로 합니다. 'sudo'로 실행해 주십시오.")
        
    except OSError as e:
        if e.errno == 98: # Address already in use
            print(f"\n[CRITICAL ERROR] 포트 {PORT}가 이미 사용 중입니다.")
            print(f"다른 서비스가 포트 {PORT}를 사용하고 있는지 확인하십시오.")
            print(f"확인 명령어: sudo netstat -tulpn | grep :{PORT}")
        else:
            print(f"\n[OS ERROR] {e}")
            
    except KeyboardInterrupt:
        print("\n\n[INFO] 사용자 요청으로 서버 중지됨 (Ctrl+C)")
        
    except Exception as e:
        print(f"\n[SERVER ERROR] 예상치 못한 오류가 발생했습니다: {e}")

if __name__ == "__main__":
    run_server()