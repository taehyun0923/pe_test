import os
import ssl
import sys
import subprocess
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import parse_qs, unquote_plus
from datetime import datetime

# =========================================================================
# Kali HTTPS Listener (Port 443) - 10GB 수신용
# 반복 전송되는 대용량 파일을 계속해서 수신하고 저장합니다.
# =========================================================================

# 저장 경로: 현재 사용자(또는 root)의 Downloads/received_data
try:
    USER_HOME = os.path.expanduser(f"~{os.getenv('SUDO_USER')}") if os.getenv('SUDO_USER') else os.path.expanduser('~')
except:
    USER_HOME = os.path.expanduser('~')

RECEIVE_DIR = os.path.join(USER_HOME, "Downloads", "received_data")
SERVER_ADDRESS = ('0.0.0.0', 443)

def generate_ssl_certs():
    cert_file = 'server.crt'
    key_file = 'server.key'
    # 기존 파일 삭제 (있다면)
    if os.path.exists(cert_file): os.remove(cert_file)
    if os.path.exists(key_file): os.remove(key_file)
    try:
        # 인증서 생성 (단일 명령)
        cmd = "openssl req -x509 -newkey rsa:4096 -keyout server.key -out server.crt -days 365 -nodes -subj '/CN=Kali_Listener'"
        subprocess.run(cmd, shell=True, check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return cert_file, key_file
    except:
        # 인증서 생성 실패 시 종료
        print("경고: 인증서 생성 실패. openssl이 설치되어 있는지 확인하세요.")
        sys.exit(1)

class LargeDataHandler(BaseHTTPRequestHandler):
    
    # do_POST 함수 내에서 직접 헤더와 응답을 처리하도록 수정
    def do_POST(self):
        if self.path != '/upload':
            self.send_response(404)
            self.end_headers()
            return

        try:
            content_length = int(self.headers.get('Content-Length', 0))
            if content_length == 0:
                self.send_response(400) # Bad Request
                self.end_headers()
                return

            # 데이터 읽기
            post_data = self.rfile.read(content_length)
            
            # 파싱 (파일명 추출)
            post_data_str = post_data.decode('utf-8', errors='ignore')
            parsed_data = parse_qs(post_data_str)
            
            filename = parsed_data.get('filename', ['data.txt'])[0]
            content = parsed_data.get('content', [''])[0]
            
            if not os.path.exists(RECEIVE_DIR): os.makedirs(RECEIVE_DIR)
            
            # 파일명 충돌 방지 (타임스탬프 추가)
            timestamp = datetime.now().strftime('%H%M%S_%f')
            save_path = os.path.join(RECEIVE_DIR, f"{timestamp}_{filename}")
            
            # 파일 저장
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            # 수신 로그 출력
            print(f"[{datetime.now().strftime('%T')}] 수신 완료: {filename} ({len(content)/1024/1024:.2f} MB)")
            
            # 응답 전송 (Connection reset 방지)
            self.send_response(200)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            self.wfile.write(b"OK received chunk") # 본문 내용 추가

        except Exception as e:
            print(f"Error: {e}")
            self.send_response(500)
            self.end_headers()

    # 메시지 로그를 비워 터미널을 깔끔하게 유지
    def log_message(self, format, *args): return

def run_server():
    cert_file, key_file = generate_ssl_certs()
    try:
        httpd = HTTPServer(SERVER_ADDRESS, LargeDataHandler)
        
        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        context.load_cert_chain(certfile=cert_file, keyfile=key_file)
        httpd.socket = context.wrap_socket(httpd.socket, server_side=True)
        
        print(f"★ 리스너 시작 (443 Port) - 저장 경로: {RECEIVE_DIR}")
        print("★ 10GB 수신 대기 중...")
        httpd.serve_forever()

    except OSError as e:
        if e.errno == 98: # Address already in use
            print("오류: 443 포트가 이미 사용 중입니다. (다른 프로세스 확인 또는 포트 변경)")
        else:
            print(f"치명적인 서버 오류: {e}")
            sys.exit(1)
    except Exception as e:
        print(f"서버 실행 중 오류 발생: {e}")
        sys.exit(1)

if __name__ == '__main__':
    run_server()