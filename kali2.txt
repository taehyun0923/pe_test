import os
import ssl
import sys
import subprocess
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import parse_qs, unquote_plus
from datetime import datetime

# =========================================================================
# Python Standard Library Only HTTPS Server - 443 포트
# Flask 없이 기본 모듈만 사용하여 대용량 데이터를 수신합니다.
# =========================================================================

# 파일 저장 경로 설정 (현재 사용자의 Downloads/received_data 폴더)
# sudo로 실행해도 실제 사용자의 폴더를 찾도록 시도하거나 /root/Downloads에 저장
try:
    USER_HOME = os.path.expanduser(f"~{os.getenv('SUDO_USER')}") if os.getenv('SUDO_USER') else os.path.expanduser('~')
except:
    USER_HOME = os.path.expanduser('~')

RECEIVE_DIR = os.path.join(USER_HOME, "Downloads", "received_data")
SERVER_ADDRESS = ('0.0.0.0', 443)

# -------------------------------------------------------------------------
# 1. SSL 인증서 생성 함수
# -------------------------------------------------------------------------
def generate_ssl_certs():
    cert_file = 'server.crt'
    key_file = 'server.key'
    
    # 기존 파일 삭제 (충돌 방지)
    if os.path.exists(cert_file): os.remove(cert_file)
    if os.path.exists(key_file): os.remove(key_file)
        
    print("★ SSL 인증서 생성 중 (OpenSSL)...")
    try:
        cmd = "openssl req -x509 -newkey rsa:4096 -keyout server.key -out server.crt -days 365 -nodes -subj '/CN=Kali_Listener'"
        subprocess.run(cmd, shell=True, check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        if os.path.exists(cert_file) and os.path.exists(key_file):
            return cert_file, key_file
        else:
            print("❌ OpenSSL 인증서 생성 실패. openssl이 설치되어 있는지 확인하세요.")
            sys.exit(1)
    except Exception as e:
        print(f"❌ 인증서 생성 중 오류: {e}")
        sys.exit(1)

# -------------------------------------------------------------------------
# 2. HTTP 요청 핸들러
# -------------------------------------------------------------------------
class LargeDataHandler(BaseHTTPRequestHandler):
    def _set_headers(self, status_code=200):
        self.send_response(status_code)
        self.send_header('Content-type', 'text/plain')
        self.end_headers()

    def do_POST(self):
        # /upload 경로만 허용
        if self.path != '/upload':
            self._set_headers(404)
            return

        try:
            # 데이터 크기 확인
            content_length = int(self.headers.get('Content-Length', 0))
            if content_length == 0:
                self._set_headers(400)
                return

            # 데이터 읽기 (대용량)
            post_data = self.rfile.read(content_length)
            
            # 데이터 파싱 (URL Decoding)
            # errors='ignore'로 인코딩 오류 방지
            post_data_str = post_data.decode('utf-8', errors='ignore')
            parsed_data = parse_qs(post_data_str)
            
            filename = parsed_data.get('filename', ['received_log.txt'])[0]
            content = parsed_data.get('content', [''])[0]
            
            # 저장
            if not os.path.exists(RECEIVE_DIR):
                os.makedirs(RECEIVE_DIR)
                
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            save_path = os.path.join(RECEIVE_DIR, f"received_{timestamp}_{filename}")
            
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            file_size = os.path.getsize(save_path) / (1024 * 1024)
            print(f"\n[{timestamp}] ✅ 파일 수신 완료!")
            print(f" - 경로: {save_path}")
            print(f" - 크기: {file_size:.2f} MB")
            
            self._set_headers(200)
            self.wfile.write(b"Upload Success")
            
        except Exception as e:
            print(f"❌ 수신 중 오류 발생: {e}")
            self._set_headers(500)

    # 로그 출력 억제 (화면 깔끔하게)
    def log_message(self, format, *args):
        return

# -------------------------------------------------------------------------
# 3. 서버 실행
# -------------------------------------------------------------------------
def run_server():
    cert_file, key_file = generate_ssl_certs()
    
    httpd = HTTPServer(SERVER_ADDRESS, LargeDataHandler)
    
    # SSL Context 설정 (최신 방식)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(certfile=cert_file, keyfile=key_file)
    httpd.socket = context.wrap_socket(httpd.socket, server_side=True)
    
    print(f"\n★ HTTPS 서버 시작됨 (Port 443)")
    print(f"★ 저장 경로: {RECEIVE_DIR}")
    print("★ 대기 중... (Ctrl+C로 종료)")
    
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\n서버 종료.")

if __name__ == '__main__':
    run_server()